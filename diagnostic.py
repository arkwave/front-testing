
import numpy as np
from math import log, sqrt, exp
import pandas as pd
from calc import compute_strike_from_delta
from scripts.prep_data import find_cdist
from scripts.portfolio import Portfolio
from scripts.classes import Future, Option

multipliers = {
    'LH':  [22.046, 18.143881, 0.025, 0.05, 400],
    'LSU': [1, 50, 0.1, 10, 50],
    'LCC': [1.2153, 10, 1, 25, 12.153],
    'SB':  [22.046, 50.802867, 0.01, 0.25, 1120],
    'CC':  [1, 10, 1, 50, 10],
    'CT':  [22.046, 22.679851, 0.01, 1, 500],
    'KC':  [22.046, 17.009888, 0.05, 2.5, 375],
    'W':   [0.3674333, 136.07911, 0.25, 10, 50],
    'S':   [0.3674333, 136.07911, 0.25, 10, 50],
    'C':   [0.393678571428571, 127.007166832986, 0.25, 10, 50],
    'BO':  [22.046, 27.215821, 0.01, 0.5, 600],
    'LC':  [22.046, 18.143881, 0.025, 1, 400],
    'LRC': [1, 10, 1, 50, 10],
    'KW':  [0.3674333, 136.07911, 0.25, 10, 50],
    'SM':  [1.1023113, 90.718447, 0.1, 5, 100],
    'COM': [1.0604, 50, 0.25, 2.5, 53.02],
    'OBM': [1.0604, 50, 0.25, 1, 53.02],
    'MW':  [0.3674333, 136.07911, 0.25, 10, 50]
}

seed = 7
np.random.seed(seed)
pd.options.mode.chained_assignment = None

# Dictionary mapping month to symbols and vice versa
month_to_sym = {1: 'F', 2: 'G', 3: 'H', 4: 'J', 5: 'K', 6: 'M',
                7: 'N', 8: 'Q', 9: 'U', 10: 'V', 11: 'X', 12: 'Z'}
sym_to_month = {'F': 1, 'G': 2, 'H': 3, 'J': 4, 'K': 5,
                'M': 6, 'N': 7, 'Q': 8, 'U': 9, 'V': 10, 'X': 11, 'Z': 12}
decade = 10


# details contract months for each commodity. used in the continuation
# assignment.
contract_mths = {

    'LH':  ['G', 'J', 'K', 'M', 'N', 'Q', 'V', 'Z'],
    'LSU': ['H', 'K', 'Q', 'V', 'Z'],
    'LCC': ['H', 'K', 'N', 'U', 'Z'],
    'SB':  ['H', 'K', 'N', 'V'],
    'CC':  ['H', 'K', 'N', 'U', 'Z'],
    'CT':  ['H', 'K', 'N', 'Z'],
    'KC':  ['H', 'K', 'N', 'U', 'Z'],
    'W':   ['H', 'K', 'N', 'U', 'Z'],
    'S':   ['F', 'H', 'K', 'N', 'Q', 'U', 'X'],
    'C':   ['H', 'K', 'N', 'U', 'Z'],
    'BO':  ['F', 'H', 'K', 'N', 'Q', 'U', 'V', 'Z'],
    'LC':  ['G', 'J', 'M', 'Q', 'V' 'Z'],
    'LRC': ['F', 'H', 'K', 'N', 'U', 'X'],
    'KW':  ['H', 'K', 'N', 'U', 'Z'],
    'SM':  ['F', 'H', 'K', 'N', 'Q', 'U', 'V', 'Z'],
    'COM': ['G', 'K', 'Q', 'X'],
    'OBM': ['H', 'K', 'U', 'Z'],
    'MW':  ['H', 'K', 'N', 'U', 'Z']
}


def generate_portfolio():
    """Generate portfolio for testing purposes. """
    # Underlying Futures
    ft1 = Future('N7', 300, 'C')
    # ft2 = Future('N7', 300, 'C')

    # options
    op1 = Option(
        320, 0.05106521860205984, 'call', 0.4245569263291844, ft1, 'amer', False, 'N7')
    op2 = Option(280, 0.05106521860205984, 'put',
                 0.4245569263291844, ft1, 'amer', True, 'N7')

    OTCs = [op1, op2]

    # creating portfolio
    pf = Portfolio()
    # pf.add_security(hedges, 'hedge')
    pf.add_security(OTCs, 'OTC')

    return pf


pf = generate_portfolio()


# FIXME: Necessary to extend this to multiple products?
def apply_signal(pf, vdf, pdf, signals, date, next_date, roll_cond, strat='dist', tol=1000):
    """Applies the signal generated by the recommendation program to the portfolio.
    Args:
        pf (object): portfolio
        vdf (pandas dataframe): dataframe of volatilities
        pdf (pandas dataframe): dataframe of prices
        signals (pandas dataframe): signals
        date (pandas Timestamp): current date
        next_date (pandas Timestamp): next date in simulation
        roll_cond (list): list of delta_roll conditions
        strat (str, optional): Description

    Returns:
        portfolio object: the portfolio with the requisite changes applied.
    """
    # identifying relevant columns; hardcoded due to formatting, change if
    # necessary.
    cols = ['delta_call_25_a', 'delta_put_25_b',
            'signal', 'opmth', 'ftmth', 'pdt', 'lots', 'vega']
    # getting inputs from signals dataframe
    print('next_date: ', next_date)

    if next_date is None:
        print('reached end of signal period')
        return pf

    cvol, pvol, sig, opmth, ftmth, pdt, lots, vega_req = signals.loc[
        signals.value_date == next_date, cols].values[0]
    inputs = [cvol, pvol, sig, opmth, ftmth, pdt, lots, vega_req]
    print('________APPLYING SIGNAL_______: ', sig)

    ret = None
    next_date = pd.to_datetime(next_date)

    # Case 1: zero signal
    if sig == 0:
        ret = Portfolio()

    # Case 2: nonzero signal
    else:
        dval = roll_cond[1]/100
        net_call_vega, net_put_vega = pf.net_vega_pos()
        target_call_vega, target_put_vega = vega_req * sig,  -vega_req * sig

        # Base case: vega legs are within bounds.
        if abs(target_call_vega - net_call_vega) < tol and abs(target_put_vega - net_put_vega) < tol:
            ret = pf

        # Case 2-1: Adding to empty portfolio.
        if net_call_vega == 0 and net_put_vega == 0:
            pf = add_skew(pf, vdf, pdf, inputs, date, next_date, dval)
            ret = pf

        # Case 2: adding to nonempty portfolio.
        else:
            # Case 2-1: buying skews. (e.g. signal 1 -> 2 or -1 -> 2)
            if target_call_vega > net_call_vega and target_put_vega < net_put_vega:
                # Case 2-1-1: Positive to positive (i.e. 10,000 -> 20,000)
                if target_call_vega > 0 and net_call_vega > 0 and target_put_vega < 0 and net_put_vega < 0:

                    pass

                # Case 2-1-2: Negative to positive.
                elif net_call_vega < 0 and target_call_vega > 0 and net_put_vega > 0 and target_put_vega < 0:
                    pf = Portfolio()
                    # make sure input list is right.
                    pf = add_skew(pf, vdf, pdf, inputs, date, next_date, dval)

                # Case 2-1-3: Liquidating short pos by buying skews.
                elif net_call_vega < 0 and target_call_vega < 0:
                    pass

            # Case 2-2: shorting skews (e.g. signal -1 -> -2)
            elif target_call_vega < net_call_vega and target_put_vega > net_put_vega:
                # Case 2-2-1: Liquidating long pos by shorting skews (i.e.
                # 20,000 -> 10,000)
                if target_call_vega > 0 and net_call_vega > 0:
                    pass

                # Case 2-2-2: Negative to negative
                elif target_call_vega < 0 and net_call_vega < 0:
                    pass

                # Case 2-2-3: Positive to negative
                elif target_call_vega < 0 and net_call_vega > 0:
                    pf = Portfolio()
                    # make sure input list is right.
                    pf = add_skew(pf, vdf, pdf, inputs, date, next_date, dval)

        ret = pf

    print('________SIGNAL APPLIED _________')
    return ret


def add_skew(pf, vdf, pdf, inputs, date, dval):
    """Helper method that adds a skew position based on the inputs provided.

    Args:
        pf (object): portfolio being hedged. 
        vdf (pandas dataframe): vol dataframe with info pertaining to date. 
        pdf (pandas dataframe): price dataframe with info pertaining to date.
        inputs (list): list corresponding to values in signals.loc[date = next_date]
        date (pandas datetime): current date in the simulation 
        dval (double): the delta value of the skew desired. 
    """

    # unpack inputs
    cvol, pvol, sig, opmth, ftmth, pdt, lots, vega_req = inputs

    # determining if options are to be shorted or not
    shorted = True if sig < 0 else False
    num_skews = abs(sig)
    cvol, pvol = cvol/100, pvol/100
    # computing ordering
    curr_mth = date.month
    curr_mth_sym = month_to_sym[curr_mth]
    curr_yr = date.year % (2000 + decade)
    curr_sym = curr_mth_sym + str(curr_yr)
    order = find_cdist(curr_sym, ftmth, contract_mths[pdt])

    # create the underlying future
    uid = pdt + '  ' + ftmth

    try:
        ftprice = pdf[(pdf.value_date == date) &
                      (pdf.underlying_id == uid)].settle_value.values[0]
    except IndexError:
        print('inputs: ', date, uid)

    ft = Future(ftmth, ftprice, pdt, shorted=False,
                lots=lots, ordering=order)

    # create the options; long one dval call, short on dval put
    vol_id = pdt + '  ' + opmth + '.' + ftmth

    # computing tau
    tau = vdf[(vdf.value_date == date) &
              (vdf.vol_id == vol_id)].tau.values[0]

    # computing strikes
    c_strike = compute_strike_from_delta(
        None, delta1=dval, vol=cvol, s=ftprice, tau=tau, char='call', pdt=pdt)
    p_strike = compute_strike_from_delta(
        None, delta1=dval, vol=pvol, s=ftprice, tau=tau, char='put', pdt=pdt)

    # creating placeholder options objects for computation purposes
    callop = Option(c_strike, tau, 'call', cvol, ft, 'amer',
                    shorted, opmth, lots=lots, ordering=order)
    putop = Option(p_strike, tau, 'put', pvol, ft, 'amer',
                   not shorted, opmth, lots=lots, ordering=order)

    # calculate lots required for requisite vega specified; done according
    # to callop.
    pnl_mult = multipliers[pdt][-1]
    call_vega = (callop.vega * 100) / (callop.lots * pnl_mult)
    print('call vega: ', call_vega)

    lots_req = round((abs(vega_req * num_skews) * 100) /
                     abs(call_vega * pnl_mult))

    tobeadded = []

    # creating and appending relevant options.
    for i in range(num_skews):
        callop = Option(c_strike, tau, 'call', cvol, ft, 'amer',
                        shorted, opmth, lots=lots_req, ordering=order)
        putop = Option(p_strike, tau, 'put', pvol, ft, 'amer',
                       not shorted, opmth, lots=lots_req, ordering=order)
        print('vegas: ', callop.vega, putop.vega)
        pf.add_security([callop, putop], 'OTC')
        tobeadded.extend([callop, putop])
    # debug statement.
    for op in tobeadded:
        print('added op deltas: ', op, abs(op.delta/op.lots))
    tobeadded.clear()

    return pf


#add_skew(pf, vdf, pdf, inputs, date, dval)
def liquidate_pos(char, target_vega, curr_vega, dval, ops, pf, strat, tol):
    """ Helper method that updates the skew position depending on the signal that is being applied to the portfolio. Does so by doing the following:

    1) checks to see if the signal requires buying or selling skews (i.e. increasing vega on each leg or   decreasing vega on each leg.)

    2) If buy signal:
        > adds the requisite skew pos to ensure that the vega on each leg is equal to target_vega * num_skews

    3) If sell signal:
        > compute sell target (i.e. curr_vega - target_vega)
        > while the required sell target > 0:
            1. select option based on strat
            2. calculate the vega per lot of that option.
            3. calculate number of lots required to liquidate required sell target.
            4. if lots required > lots available:  
                - decrement sell target by num_lots * vpl
                - remove option from portfolio
                - select new option
            5. back to step 1. 

    Notes:
        - for readability: vpl = vega per lot.

    Args:
        char (string): the type of option being handled. valid inputs: 'call' & 'put'
        target_vega (TYPE): the vega desired on this leg of the skew. 
        curr_vega (TYPE): current vega on this leg of the skew.
        dval (TYPE): delta value of the skew desired. 
        ops (TYPE): list of options to be selected from. 
        pf (TYPE): portfolio object being subjected to the signal.
        strat (TYPE): the regime used to determine which skew positions are liquidated first. 
        tol (TYPE): tolerance level for vega. if abs(curr_vega - target_vega) < tol, do nothing. 
        vdf (TYPE): dataframe of volatilities specific to this particular day. 
        pdf (TYPE): dataframe of prices specific to this particular day. 
        inputs (TYPE): list of inputs passed into add_skew function [refer there for details]
        date (TYPE): current date in the simulation.
        next_date (TYPE): next date in the simulation. 

    Returns:
        portfolio: the updated portfolio with the appropriate equivalent position liquidated.


    """
    print('HANDLING ' + char.upper())
    toberemoved = []
    # shorted = -1 if curr_vega > target_vega else 1
    buy = True if target_vega > curr_vega else False
    vega_req = abs(target_vega - curr_vega)

    # Case 1: need to buy vega (i.e. increase long position, or go from net
    # short to net long)
    if buy:
        # Case 1-1: negative to positive pos. (e.g. -30,000 -> 10,000)
        if curr_vega < 0 and target_vega > 0:
            pf = Portfolio()
            pf = add_skew(pf, vdf, pdf, inputs, date, dval)
        # case 1-2: nonnegative to positive pos (e.g. 10,000 -> 20,000)
        else:
            print('calls - increasing long pos')
            vpl = max_op.vega / max_op.lots
            newlots = max_op.lots + round(vega_req/vpl)
            print('calls - newlots: ', newlots)
            max_op.update_lots(newlots)
            break
    # Case 2: need to sell vega (i.e. increase short position, or go from net
    # long to net short)
    else:
        while vega_req > 0:
            if strat == 'dist':
                print('selecting skew acc to dist')
                print('portfolio at loop start: ', pf)
                ops = sorted(ops, key=lambda x: abs(
                    abs(x.delta/x.lots) - dval))
                max_op = ops[-1] if ops else None

            elif strat == 'filo':
                print('selecting skew acc to filo')
                print('portfolio at loop start: ', pf)
                max_op = ops[0] if ops else None

            # Case 2: need to sell vega.
            # Case 2-1: negative to negative (e.g. -10,000 to -30,000).
            # increase lots in short pos selected accord
            if curr_vega < 0 and target_vega < 0:
                print('calls - increasing short pos')
                vpl = max_op.vega / max_op.lots
                newlots = max_op.lots + round(vega_req/vpl)
                print('calls - newlots: ', newlots)
                max_op.update_lots(newlots)
                break
            # Case 2-2: positive to negative (e.g. -10,000 -> 10,000). In this case, zero out portfolio
            # and then add short skews up to the requisite amount.
            else:
                pf = Portfolio()
                pf = add_skew(pf, vdf, pdf, inputs, date, dval)
                break
    # update any lot size changes
    pf.update_sec_by_month(False, 'OTC', update=True)

    # remove securities flagged for removal
    pf.remove_security(toberemoved, 'OTC')

    # debug statement
    for op in toberemoved:
        print('op removed deltas: ', op, abs(op.delta/op.lots))
    toberemoved.clear()
    print('pf after liquidation: ', pf)
    return pf



def apply_signal(pf, vdf, pdf, signals, date, next_date, roll_cond, strat='dist', tol=3000):
    """Applies the signal generated by the recommendation program to the portfolio.
    Args:
        pf (object): portfolio
        vdf (pandas dataframe): dataframe of volatilities
        pdf (pandas dataframe): dataframe of prices
        signals (pandas dataframe): signals
        date (pandas Timestamp): current date
        next_date (pandas Timestamp): next date in simulation
        roll_cond (list): list of delta_roll conditions
        strat (str, optional): Description

    Returns:
        portfolio object: the portfolio with the requisite changes applied.
    """
    # identifying relevant columns; hardcoded due to formatting, change if
    # necessary.
    cols = ['delta_call_25_a', 'delta_put_25_b',
            'signal', 'opmth', 'ftmth', 'pdt', 'lots', 'vega']
    # getting inputs from signals dataframe
    print('next_date: ', next_date)

    if next_date is None:
        print('reached end of signal period')
        return pf

    cvol, pvol, sig, opmth, ftmth, pdt, lots, vega_req = signals.loc[
        signals.value_date == next_date, cols].values[0]

    print('________APPLYING SIGNAL_______: ', sig)

    ret = None
    next_date = pd.to_datetime(next_date)

    # Case 1: flatten signal
    if sig == 0:
        ret = Portfolio()

    else:
        dval = roll_cond[1]/100

        # determining if options are to be shorted or not
        shorted = True if sig < 0 else False
        cvol, pvol = cvol/100, pvol/100
        # computing ordering
        curr_mth = date.month
        curr_mth_sym = month_to_sym[curr_mth]
        curr_yr = date.year % (2000 + decade)
        curr_sym = curr_mth_sym + str(curr_yr)
        order = find_cdist(curr_sym, ftmth, contract_mths[pdt])

        # create the underlying future
        uid = pdt + '  ' + ftmth
        try:
            ftprice = pdf[(pdf.value_date == date) &
                          (pdf.underlying_id == uid)].settle_value.values[0]
        except IndexError:
            print('inputs: ', date, uid)

        ft = Future(ftmth, ftprice, pdt, shorted=False,
                    lots=lots, ordering=order)

        # create the options; long one dval call, short on dval put
        vol_id = pdt + '  ' + opmth + '.' + ftmth

        # computing tau
        tau = vdf[(vdf.value_date == date) &
                  (vdf.vol_id == vol_id)].tau.values[0]

        # computing strikes
        c_strike = compute_strike_from_delta(
            None, delta1=dval, vol=cvol, s=ftprice, tau=tau, char='call', pdt=pdt)
        p_strike = compute_strike_from_delta(
            None, delta1=dval, vol=pvol, s=ftprice, tau=tau, char='put', pdt=pdt)

        # creating placeholder options objects for computation purposes
        callop = Option(c_strike, tau, 'call', cvol, ft, 'amer',
                        shorted, opmth, lots=lots, ordering=order)
        putop = Option(p_strike, tau, 'put', pvol, ft, 'amer',
                       not shorted, opmth, lots=lots, ordering=order)

        # calculate lots required for requisite vega specified; done according
        # to callop.
        pnl_mult = multipliers[pdt][-1]

        call_vega = (callop.vega * 100) / (callop.lots * pnl_mult)
        print('call vega: ', call_vega)

        # lots_req = round(
        #     abs(((vega_req * num_skews * 100) / call_vega * pnl_mult)))
        lots_req = round((abs(vega_req * num_skews) * 100) /
                         abs(call_vega * pnl_mult))

        # print('lots req: ', lots_req)
        # initializing useful variables
        long_calls = [op for op in pf.OTC_options if op.char ==
                      'call' and op.shorted == False]
        short_puts = [op for op in pf.OTC_options if op.char ==
                      'put' and op.shorted == True]
        short_calls = [op for op in pf.OTC_options if op.char ==
                       'call' and op.shorted == True]
        long_puts = [op for op in pf.OTC_options if op.char ==
                     'put' and op.shorted == False]

        if (not pf.empty() and (sig < 0) and (long_calls) and (short_puts)):
            # Case 2-1: close off existing long skew pos selected according to strat
            # when getting sell sig
            print('sig < 0; liquidating long skew pos')
            calls = long_calls
            puts = short_puts
            ret = liquidate_skew_pos(vega_req, num_skews, dval,
                                     calls, puts, pf, strat)

        elif (not pf.empty() and (sig > 0) and (short_calls) and (long_puts)):
            # Case 2-2: close off existing short skew pos selected according to strat
            # when getting buy sig.
            print('sig > 0; liquidating short skew pos')
            calls = short_calls
            puts = long_puts
            ret = liquidate_skew_pos(vega_req, num_skews, dval,
                                     calls, puts, pf, strat)

        # Other 4 cases: buy/sell with empty portfolio, or buy with no
        # shorts/sell with no longs
        else:
            print('non-liquidation signal')
            print('lots: ', lots_req)
            tobeadded = []
            for i in range(num_skews):
                callop = Option(c_strike, tau, 'call', cvol, ft, 'amer',
                                shorted, opmth, lots=lots_req, ordering=order)
                putop = Option(p_strike, tau, 'put', pvol, ft, 'amer',
                               not shorted, opmth, lots=lots_req, ordering=order)
                print('vegas: ', callop.vega, putop.vega)
                pf.add_security([callop, putop], 'OTC')
                tobeadded.extend([callop, putop])

            for op in tobeadded:
                print('added op deltas: ', op, abs(op.delta/op.lots))
            tobeadded.clear()

        # one final sanity check: if option lists are empty and there are hedge futures, close them
        # all out.

        ret = close_out_deltas(pf, ftprice)

    print('_________ SIGNAL APPLIED __________')

    return ret


# FIXME; figure out if this needs to handle multiple products.
def liquidate_pos(char, resid_vega, ops, pf, strat, dval):
    """Buys/Sells (vega_req * num_req) worth of dval skew composites. For example if vega = 10000, num_skews =1 and dval = 25, then the function figures out how to liquidate 10,000 vega worth of that day's 25 Delta skew positions ON EACH LEG (i.e. a Long 25 Delta Call and a Short 25 Delta Put) from the currently held position.

Does so by selecting  a skew position to liquidate based on strat;
currently implemented strategies for liquidation are 'dist' (the options
selected are furthest away from dval) and 'filo' (first in last out),
computing the vega per lot of that skew position, and liquidating the
required number of lots. If the number of lots contained in the selected
skew position is smaller than the number of lots required, the skew
position is completely closed out (i.e. shorts are bought back, longs
are sold) and the leftover vega is liquidated using the next highest
skew pos, selected according to strat.

If all options of a given type have been spent in this manner and
liquidation is still not complete, the algorithm simply skips to handle
options of the next type. In the pathological case where the entire
portfolio's contents are insufficient to meet the liquidation condition,
the entire portfolio is closed, and remaining deltas from hedging are
closed off.

In practice, since we're interested in the call-side (long skew), lots
required for the requisite vega is determined by the call option. Put
option is instantiated with exactly the same number of lots, which could
lead to a slight vega differential (currently being ignored, but might
need to be addressed in the future).


    Notes:
        - for readability: vpl = vega per lot.
    Args:
        vega_req (TYPE): total amount of vega to be liquidated.
        num_skews (TYPE): number of buy/sell signals on this day. total vega to be liquidated would be vega_req * num_skews
        dval (TYPE): delta value of the skew pos we want to run.
        calls (TYPE): list of call options selected according to which liquidation scenario is in effect (i.e. liquidating shorts with a buy signal, or liquidating longs with a sell signal)
        puts (TYPE): list of put options selected according to which liquidation scenario is in effect.
        pf (TYPE): portfolio object being subjected to the signal.
strat (TYPE): the regime used to determine which skew positions are
liquidated first.

    Returns:
        portfolio: the updated portfolio with the appropriate equivalent position liquidated.
    """

    toberemoved = []

    # handling puts
    print('HANDLING ' + char.upper())
    while resid_vega > 0:
        print('residual vega: ', resid_vega)
        if strat == 'dist':
            print('selecting skew acc to dist')
            print('portfolio at loop start: ', pf)
            put_ops = sorted(ops, key=lambda x: abs(
                abs(x.delta/x.lots) - dval))

            max_put_op = put_ops[-1] if put_ops else None

            # print('putops: ', [str(p) for p in put_ops])
        elif strat == 'filo':
            print('selecting skew acc to filo')
            print('portfolio at loop start: ', pf)
            max_op = ops[0] if ops else None

        if max_op is not None:

            print('op selected: ', max_op)
            # handle puts
            vpl = abs(max_op.vega/max_op.lots)
            print('puts vega per lot: ', vpl)
            put_lots_req = round(abs(resid_vega / vpl))
            print('put lots req: ', put_lots_req)

            # Case 1: lots required < lots available.
            if put_lots_req < max_put_op.lots:
                print('l_puts: lots available.')
                resid_vega = 0
                newlots = max_put_op.lots - put_lots_req
                max_put_op.update_lots(newlots)
                print('puts - new lots: ', newlots)
                # break

            # Case 2: lots required > lots available.
            else:
                print('l_puts: lots unavailable.')
                resid_vega -= max_op.lots * vpl
                toberemoved.append(max_op)
                ops.remove(max_op)
        else:
            print(
                'cannot liquidate existing positions any further. continuing to handle calls..')
            break

    # update any lot size changes
    pf.update_sec_by_month(False, 'OTC', update=True)

    # remove securities flagged for removal
    pf.remove_security(toberemoved, 'OTC')

    # debug statement
    for op in toberemoved:
        print('op removed deltas: ', op, abs(op.delta/op.lots))
    toberemoved.clear()
    print('pf after liquidation: ', pf)
    return pf


##################################################
# old hedging implementation (changed 7/26/2017) #
##################################################


def rebalance(vdf, pdf, pf, hedges, counters, brokerage=None, slippage=None):
    """Function that handles EOD greek hedging. Calls hedge_delta and hedge_gamma_vega.

    Notes:
        1) hedging gamma and vega done by buying/selling ATM straddles. No liquidity constraints assumed.
        2) hedging delta done by shorting/buying -delta * lots futures.
        3)

    Args:
        vdf (pandas dataframe): Dataframe of volatilities
        pdf (pandas dataframe): Dataframe of prices
        pf (object): portfolio object
        hedges (dict): Dictionary of hedging conditions
        counters (TYPE): Description
        brokerage (None, optional): Description
        slippage (None, optional): Description

    Returns:
        tuple: portfolio, counters
    """
    # compute the gamma and vega of atm straddles; one call + one put.
    # compute how many such deals are required. add to appropriate pos.
    # return both the portfolio, as well as the gain/loss from short/long pos
    # hedging delta, gamma, vega.
    delta_freq, gamma_freq, theta_freq, vega_freq = counters
    # print('delta freq: ', delta_freq)
    # print('vega freq: ', vega_freq)
    dic = copy.deepcopy(pf.get_net_greeks())
    hedgearr = [False, False, False, False]
    droll = None
    # updating counters
    if pf.empty():
        return pf, counters, 0, False

    for greek in hedges:
        if greek == 'delta':
            if delta_freq == hedges[greek][0][2]:
                counters[0] = 1
                hedgearr[0] = True
            else:
                print('delta freq not met.')
                counters[0] += 1
        elif greek == 'gamma':
            if gamma_freq == hedges[greek][0][2]:
                counters[1] = 1
                hedgearr[1] = True
            else:
                print('gamma freq not met')
                counters[1] += 1
        elif greek == 'vega':
            if vega_freq == hedges[greek][0][2]:
                counters[3] = 1
                hedgearr[3] = True
            else:
                print('vega freq not met')
                counters[3] += 1
        elif greek == 'theta':
            if theta_freq == hedges[greek][0][2]:
                counters[2] = 1
                hedgearr[2] = True
            else:
                print('gamma freq not met')
                counters[2] += 1

    done_hedging = hedges_satisfied(pf, hedges)
    roll_hedged = check_roll_status(pf, hedges)
    droll = not roll_hedged

    cost = 0

    if roll_hedged:
        print('deltas within bounds. skipping roll_hedging')

    if not roll_hedged:
        print(' ++ ROLL HEDGING REQUIRED ++ ')
        for op in pf.OTC_options:
            print('delta: ', abs(op.delta / op.lots))
        roll_cond = [hedges['delta'][i] for i in range(len(hedges['delta'])) if hedges[
            'delta'][i][0] == 'roll'][0]
        pf, exp = hedge_delta_roll(
            pf, roll_cond, pdf, brokerage=brokerage, slippage=slippage)
        cost += exp

    hedge_count = 0
    while (not done_hedging and hedge_count < 10):
        for product in dic:
            for month in dic[product]:
                ordering = pf.compute_ordering(product, month)
                # vega/gamma/theta hedging. loop allows for dynamic hedging
                # dict.
                for strat in hedges:
                    # print(strat)
                    if strat == 'delta':
                        continue
                    # updating counters and setting bool
                    elif strat == 'gamma' and hedgearr[1]:
                        inputs = gen_hedge_inputs(
                            hedges, vdf, pdf, month, pf, product, ordering, strat)
                        pf, fees = hedge(pf, inputs, product, month,
                                         strat, brokerage=brokerage, slippage=slippage)
                    elif strat == 'vega' and hedgearr[3]:
                        inputs = gen_hedge_inputs(
                            hedges, vdf, pdf, month, pf, product, ordering, strat)
                        pf, fees = hedge(pf, inputs, product, month,
                                         strat, brokerage=brokerage, slippage=slippage)

                    elif strat == 'theta' and hedgearr[2]:
                        inputs = gen_hedge_inputs(
                            hedges, vdf, pdf, month, pf, product, ordering, strat)
                        pf, fees = hedge(pf, inputs, product, month,
                                         strat, brokerage=brokerage, slippage=slippage)
                    cost += fees
                if hedgearr[0]:
                    # grabbing condition that indicates zeroing condition on
                    # delta
                    delta_cond = [hedges['delta'][i] for i in range(len(hedges['delta'])) if hedges[
                        'delta'][i][0] == 'static']
                    if delta_cond:
                        delta_cond = delta_cond[0][1]
                    # print('delta conds: ', delta_cond)
                        pf, dhedges, fees, broken = hedge_delta(
                            delta_cond, vdf, pdf, pf, month, product, ordering, brokerage=brokerage, slippage=slippage)
                        if broken:
                            break
                        cost += fees
                    else:
                        print('no delta hedging specifications found')
        done_hedging = hedges_satisfied(pf, hedges)
        hedge_count += 1

    return (pf, counters, cost, droll)


def gen_hedge_inputs(hedges, vdf, pdf, month, pf, product, ordering, flag):
    """Helper function that generates the inputs required to construct atm
    straddles for hedging, based on the flag.

    Args:
        hedges (dict): hedging rules.
        vdf (pandas dataframe): volatility dataframef
        pdf (pandas dataframe): price dataframe
        month (string): month being hedged
        pf (object): portfolio being hedged
        product (string): product being hedged
        ordering (int): ordering corresponding to month being hedged
        flag (string): gamma, vega or theta

    Returns:
        list: inputs required to construct atm straddles.
    """
    net_greeks = pf.get_net_greeks()
    greeks = net_greeks[product][month]
    if flag == 'gamma':
        greek = greeks[1]
    elif flag == 'vega':
        greek = greeks[3]
    elif flag == 'theta':
        greek = greeks[2]
    # grabbing bound
    relevant_conds = [hedges[flag][i] for i in range(len(hedges[flag])) if hedges[
        flag][i][0] == 'bound'][0]
    bound = relevant_conds[1]
    # print('relevant_conds: ', relevant_conds)
    # print('bound: ', bound)
    uid = product + '  ' + month
    # relevant data for constructing Option and Future objects.
    price = pdf[(pdf.pdt == product) &
                (pdf.underlying_id == uid)].settle_value.values[0]
    ticksize = multipliers[product][-2]
    print('gen_hedge_inputs - ticksize: ', ticksize, product)
    k = round(round(price / ticksize) * ticksize, 2)
    # print('[8]  STRIKE: ', k)
    cvol = vdf[(vdf.pdt == product) &
               (vdf.call_put_id == 'C') &
               (vdf.underlying_id == uid) &
               (vdf.strike == k)].settle_vol.values[0]

    pvol = vdf[(vdf.pdt == product) &
               (vdf.call_put_id == 'P') &
               (vdf.underlying_id == uid) &
               (vdf.strike == k)].settle_vol.values[0]

    # if no tau provided, default to using same-month atm straddles.
    tau_vals = vdf[(vdf.pdt == product) &
                   (vdf.call_put_id == 'P') &
                   (vdf.underlying_id == uid) &
                   (vdf.strike == k)].tau

    if len(relevant_conds) == 3:
        tau = max(tau_vals)

    else:
        target = relevant_conds[3]
        # tau value passed in is an absolute TTM desired
        if target > 1:
            tau = min(tau_vals, key=lambda x: abs(x - target))

        # TODO: need to change this to
        # tau value is a ratio; assume it's ratio * contract_month option
        else:
            tau = max(tau_vals) * target

    underlying = Future(month, price, product, ordering=ordering)

    return [price, k, cvol, pvol, tau, underlying, greek, bound, ordering]


def hedge(pf, inputs, product, month, flag, brokerage=None, slippage=None):
    """
    This function does the following:
        1) constructs atm straddles with the inputs from _inputs_
        2) hedges the greek in question (specified by flag) with the straddles.

    Args:
        pf (portfolio object): portfolio object
        inputs (list): list of inputs reqd to construct straddle objects
        product (string): the product being hedged
        month (string): month being hedged
        flag (TYPE): Description
        brokerage (None, optional): Description
        slippage (None, optional): Description

    Returns:
        tuple: cost of the hedge, and the updated portfolio
    """
    # print(flag + ' ' + product + ' ' + month + ' ' + str(inputs))
    fees = 0
    price, k, cvol, pvol, tau, underlying, greek, bound, ordering = inputs

    # creating straddle components.
    callop = Option(k, tau, 'call', cvol, underlying,
                    'euro', month=month, ordering=ordering, shorted=None)

    putop = Option(k, tau, 'put', pvol, underlying,
                   'euro', month=month, ordering=ordering, shorted=None)

    lm, dm = multipliers[product][1], multipliers[product][0]

    # gamma and vega hedging.
    upper = bound[1]
    lower = bound[0]
    # print('upper: ', upper)
    # print('lower: ', lower)
    print('>>>>>>>>>>> hedging ' + product + ' ' +
          month + ' ' + flag + ' <<<<<<<<<<<<<')
    if greek > upper or greek < lower:
        # gamma hedging logic.

        # print(product + ' ' + month + ' ' + flag + ' hedging')
        print('cvol: ', cvol)
        print('pvol: ', pvol)
        if greek < lower:
            # print('lower')
            # need to buy straddles for gamma/vega, short for theta.
            if flag == 'gamma':
                callop.shorted = False
                putop.shorted = False
                cdelta, cgamma, ctheta, cvega = callop.greeks()
                pdelta, pgamma, ptheta, pvega = putop.greeks()
                greek_c = (cgamma * dm) / (callop.lots * lm)
                greek_p = (pgamma * dm) / (putop.lots * lm)
                # pgreek, cgreek = pgamma, cgamma
                lots_req = round((abs(greek) * dm) /
                                 ((greek_c + greek_p) * lm))

            elif flag == 'vega':
                # print('LONG debug [1] - vega below lower', greek, lower)
                callop.shorted = False
                putop.shorted = False
                cdelta, cgamma, ctheta, cvega = callop.greeks()
                pdelta, pgamma, ptheta, pvega = putop.greeks()
                greek_c = (cvega * 100) / (callop.lots * lm * dm)
                greek_p = (pvega * 100) / (putop.lots * lm * dm)
                # pgreek, cgreek = pvega, cvega
                lots_req = round((abs(greek) * 100) /
                                 ((greek_c + greek_p) * lm * dm))
                # print('actual greeks: ', greek * 100,
                #       abs(greek_c + greek_p), lm, dm)

            elif flag == 'theta':
                # print('theta < lower: shorting straddles.')
                callop.shorted = True
                putop.shorted = True
                cdelta, cgamma, ctheta, cvega = callop.greeks()
                pdelta, pgamma, ptheta, pvega = putop.greeks()
                greek_c = (ctheta * 365) / (callop.lots * lm * dm)
                greek_p = (ctheta * 365) / (putop.lots * lm * dm)
                # pgreek, cgreek = ptheta, ctheta
                lots_req = round((abs(greek) * 365) /
                                 ((greek_c + greek_p) * lm * dm))

            callop.lots, putop.lots = lots_req, lots_req

        elif greek > upper:
            # need to short straddles for gamma/vega, long theta.
            # print('upper')
            if flag == 'gamma':
                callop.shorted = True
                putop.shorted = True
                cdelta, cgamma, ctheta, cvega = callop.greeks()
                pdelta, pgamma, ptheta, pvega = putop.greeks()
                greek_c = (cgamma * dm) / (callop.lots * lm)
                greek_p = (pgamma * dm) / (putop.lots * lm)
                # pgreek, cgreek = pgamma, cgamma
                lots_req = round((greek * dm) / (abs(greek_c + greek_p) * lm))

            elif flag == 'vega':
                # print('SHORT debug [1] - vega exceeds upper', greek, upper)
                callop.shorted = True
                putop.shorted = True
                cdelta, cgamma, ctheta, cvega = callop.greeks()
                pdelta, pgamma, ptheta, pvega = putop.greeks()
                greek_c = (cvega * 100) / (callop.lots * lm * dm)
                greek_p = (pvega * 100) / (putop.lots * lm * dm)
                # pgreek, cgreek = pvega, cvega
                lots_req = round(
                    (greek * 100) / (abs(greek_c + greek_p) * lm * dm))
                # print('actual greeks: ', greek * 100,
                #       abs(greek_c + greek_p), lm, dm)

            elif flag == 'theta':
                # print('theta > upper: buying straddles.')
                callop.shorted = False
                putop.shorted = False
                cdelta, cgamma, ctheta, cvega = callop.greeks()
                pdelta, pgamma, ptheta, pvega = putop.greeks()
                greek_c = (ctheta * 365) / (callop.lots * lm * dm)
                greek_p = (ctheta * 365) / (putop.lots * lm * dm)
                # pgreek, cgreek = ptheta, ctheta
                lots_req = round(
                    (greek * 365) / (abs(greek_c + greek_p) * lm * dm))

            callop.lots, putop.lots = lots_req, lots_req

        callops = [callop]
        putops = [putop]
        cd, cg, ct, cv = callop.greeks()
        pd, pg, pt, pv = putop.greeks()

        if brokerage:
            fees = brokerage * 2 * lots_req

        if slippage:
            ttm = callop.tau * 365
            if ttm < 60:
                s_val = slippage[0]
            elif ttm >= 60 and ttm < 120:
                s_val = slippage[1]
            else:
                s_val = slippage[-1]
            fees += (s_val * lots_req * 2)
            # fees += (slippage * 2 * lots_req)

        pf.add_security(callops, 'hedge')
        pf.add_security(putops, 'hedge')
    else:
        print(str(product) + ' ' + str(month) + ' ' + flag.upper() +
              ' WITHIN BOUNDS. SKIPPING HEDGING')
        pass
    print('hedging fees - ' + flag + ': ', fees)
    print('>>>>>>>>>>>>>>>>>><<<<<<<<<<<<<<<<<<<')
    return pf, fees   # [callop, putop]


# NOTE: assuming that future can be found with the exact number of
# lots to delta hedge.
def hedge_delta(cond, vdf, pdf, pf, month, product, brokerage=None, slippage=None):
    """Helper function that implements delta hedging. General idea is to zero out delta at the end
    of the day by buying/selling -delta * lots futures. Returns expenditure (which is negative if shorting and
    postive if purchasing delta) and the updated portfolio object.

    Args:
        cond (string): condition for delta hedging
        vdf (dataframe): Dataframe of volatilities
        pdf (dataframe): Dataframe of prices
        pf (portfolio): portfolio object specified by portfolio_specs.txt
        month (str): month of underlying future.
        product (TYPE): Description
        ordering (TYPE): Description
        brokerage (None, optional): Description
        slippage (None, optional): Description

    Returns:
        tuple: hedging costs and final portfolio with hedges added.

    Deleted Parameters:
        net (list): greeks associated with net_greeks[product][month]

    """
    # print('cond: ', cond)
    print('>>>>>>>>>>> delta hedging: ', product +
          '  ' + month + ' <<<<<<<<<<<<<')
    uid = product + '  ' + month
    try:
        future_price = pdf[(pdf.pdt == product) &
                           (pdf.underlying_id == uid)].settle_value.values[0]
    except IndexError:
        print('simulation.hedge_delta : price data not found. skipping hedging...')
        return pf, None, 0, True

    net_greeks = pf.get_net_greeks()
    fees = 0
    date = pd.to_datetime(pdf.value_date.unique()[0])
    # print('cond: ', cond)
    if cond == 'zero':
        # flag that indicates delta hedging.
        vals = net_greeks[product][month]
        delta = vals[0]
        shorted = True if delta > 0 else False
        num_lots_needed = abs(round(delta))
        if num_lots_needed == 0:
            print(str(product) + ' ' + str(month) +
                  ' DELTA IS ZEROED. SKIPPING HEDGING')
            return pf, None, 0, False
        else:
            ft = create_underlying(
                product, month, pdf, date, ftprice=future_price, shorted=shorted, lots=num_lots_needed)
            pf.add_security([ft], 'hedge')
    if brokerage:
        fees = brokerage * num_lots_needed
    print('hedging fees - delta: ', fees)
    print('>>>>>>>>>>>>>>>>>>>>>>>>>>><<<<<<<<<<<<<<<<<<<<<<<<<')
    return pf, ft, fees, False


# def read_data(epath, specpath, signals=None, start_date=None, end_date=None, test=False, writeflag=None, write=False, pdt=None, opmth=None, ftmth=None):
#     """Wrapper method that handles all read-in and preprocessing. This function does the following:
#     1) reads in path to volatility, price and expiry tables from portfolio_specs.txt
#     2) reads in dataframes from said paths
# 3) cleans that data in different ways, depending on the flag passed in.
# Exact information can be found in clean_data function.

#     Args:
#         volpath (str): path to the volatility DF

#         pricepath (str): path to the price DF

#         epath (str): path to the option expiry DF

# start_date (pd.Timestamp, optional): Desired start date for the
# simulation. Defaults to None, in which case the starting date selected
# is the earliest date such that all vol_ids in the volatility dataframe
# have data.

# end_date (str, optional): Desired end date for the simulation. Defaults
# to None, in which case the end date selected is the latest date such
# that all vol_ids in the volatility dataframe have data.

# test (bool, optional): flag used to indicate if the function is called
# as part of a test or as part of the actual simulation. Test=True writes
# the resultant dataframes to the path specified, subjected to writeflag,
# while test=False does not write any dataframes to csv.

# writeflag (str, optional): Determines where the datasets are being
# written to.

#     Returns:
# pandas dataframes x 4: volatility data, price data, expiry data, and
# cleaned prices (to be used exclusively for rollover dates)

#     Raises:
# ValueError: Raised if the start date is inconsistent with the datasets.

#     """

#     t = time.clock()
#     vid_list = []
#     try:
#         # get paths
#         print('exp: ', osf.path.exists(epath))
#         print('specs: ', osf.path.exists(specpath))

#         priceDF, volDF = pull_relevant_data(pf_path=specpath, signals=signals,
#                                             start_date=start_date, end_date=end_date,
#                                             pdt=pdt, opmth=opmth, ftmth=ftmth)
#         edf = pd.read_csv(epath).dropna()

#         if osf.path.exists(specpath):
#             specs = pd.read_csv(specpath)
#             vid_list = specs[specs.Type == 'Option'].vol_id.unique()

#         # fixing datetimes
#         volDF.value_date = pd.to_datetime(volDF.value_date)
#         priceDF.value_date = pd.to_datetime(priceDF.value_date)

#         # case 1: drawing based on portfolio.
#         if signals is not None:
#             signals.value_date = pd.to_datetime(signals.value_date)
#             volDF, priceDF = match_to_signals(volDF, priceDF, signals)

#         print('prep_data.read_data - pdf dates: ',
#               pd.to_datetime(priceDF.value_date.unique()))

#         print('vid list: ', vid_list)

#         # get effective start date, pick whichever is max

#         # case 2: drawing based on pdt, ft and opmth
#         if not any(i is None for i in [pdt, opmth, ftmth]):
#             vid_list = [pdt + '  ' + opmth + '.' + ftmth]

#         dataset_start_date = get_min_start_date(
#             volDF, priceDF, vid_list, signals=signals)
#         print('datasets start date: ', dataset_start_date)

#         dataset_start_date = pd.to_datetime(dataset_start_date)

#         start_date = dataset_start_date if (start_date is None) or \
#             ((start_date is not None) and (dataset_start_date > start_date)) else start_date

#         print('prep_data start_date: ', start_date)

#         # filtering relevant dates
#         volDF = volDF[(volDF.value_date >= start_date) &
#                       (volDF.value_date <= end_date)] \
#             if end_date \
#             else volDF[(volDF.value_date >= start_date)]

#         priceDF = priceDF[(priceDF.value_date >= start_date) &
#                           (priceDF.value_date <= end_date)] \
#             if end_date \
#             else priceDF[(priceDF.value_date >= start_date)]

#         print('prep_data.read_data - pdf dates: ',
#               pd.to_datetime(priceDF.value_date.unique()))

#         # catch errors
#         if (volDF.empty or priceDF.empty):
#             raise ValueError(
#                 '[scripts/prep_data.read_data] : Improper start date entered; resultant dataframes are empty')
#         print('pdf: ', priceDF)
#         print('vdf: ', volDF)
#         # clean dataframes
#         edf = clean_data(edf, 'exp', writeflag=writeflag)
#         final_vol = clean_data(volDF, 'vol', date=start_date,
#                                edf=edf, writeflag=writeflag)
#         final_price = clean_data(priceDF, 'price', date=start_date,
#                                  edf=edf, writeflag=writeflag)

#         print('prep_data.read_data - pdf dates: ',
#               pd.to_datetime(priceDF.value_date.unique()))
#         # final preprocessing steps
#         # final_price = ciprice(priceDF)
#         # final_vol = civols(volDF, final_price)

#         print('sanity checking date ranges')
#         if not np.array_equal(pd.to_datetime(final_vol.value_date.unique()),
#                               pd.to_datetime(final_price.value_date.unique())):
#             vmask = final_vol.value_date.isin([x for x in final_vol.value_date.unique()
#                                                if x not in final_price.value_date.unique()])
#             pmask = final_price.value_date.isin([x for x in final_price.value_date.unique()
#                                                  if x not in final_vol.value_date.unique()])
#             final_vol = final_vol[~vmask]
#             final_price = final_price[~pmask]

#     except FileNotFoundError:
#         print('files not found! printing paths below...')
#         print(epath)
#         import os
#         print(os.getcwd())
#     elapsed = time.clock() - t

#     print('[READ_DATA] elapsed: ', elapsed)
#     if writeflag:
#         if writeflag == 'small':
#             writestr = 'small_' + gvpdt.lower()
#         else:
#             writestr = 'full_' + gvpdt.lower()

#         print('writestr: ', writestr)

#     if not test:
#         vbd = vol_by_delta(final_vol, final_price)

#         # merging vol_by_delta and price dataframes on product, underlying_id,
#         # value_date and order
#         vbd.underlying_id = vbd.underlying_id.str.split().str[0]\
#             + '  ' + vbd.underlying_id.str.split().str[1]
#         final_price.underlying_id = final_price.underlying_id.str.split().str[0]\
#             + '  ' + final_price.underlying_id.str.split().str[1]
#         merged = pd.merge(vbd, final_price, on=[
#                           'pdt', 'value_date', 'underlying_id', 'order'])
#         final_price = merged

#         # handle conventions for vol_id in price/vol data.
#         final_vol.vol_id = final_vol.vol_id.str.split().str[0]\
#             + '  ' + final_vol.vol_id.str.split().str[1]
#         final_price.vol_id = final_price.vol_id.str.split().str[0]\
#             + '  ' + final_price.vol_id.str.split().str[1]
#     if write:
#         final_vol.to_csv('datasets/' + writestr +
#                          '/final_vols.csv', index=False)
#         final_price.to_csv('datasets/' + writestr +
#                            '/final_price.csv', index=False)
#         edf.to_csv('datasets/' + writestr + '/final_expdata.csv', index=False)

#     return final_vol, final_price, edf, priceDF


############# Old ciprice/civols implementation ################


def ciprice(pricedata, rollover='opex'):
    """Constructs the CI price series.

    Args:
        pricedata (TYPE): price data frame of same format as read_data
        rollover (str, optional): the rollover strategy to be used. defaults to opex, i.e. option expiry.

    Returns:
        pandas dataframe : Dataframe with the following columns:
            Product | date | underlying | order | settle_value | returns | expiry date
    """
    t = time.time()
    if rollover == 'opex':
        ro_dates = get_rollover_dates(pricedata)
        products = pricedata['pdt'].unique()
        # iterate over produts
        by_product = None
        for product in products:
            df = pricedata[pricedata.pdt == product]
            # lst = contract_mths[product]
            assert not df.empty
            most_recent = []
            by_date = None
            try:
                relevant_dates = ro_dates[product]
            except KeyError:
                df2 = df[
                        ['pdt', 'value_date', 'underlying_id', 'order', 'settle_value', 'returns', 'expdate']]
                df2.columns = [
                    'pdt', 'value_date', 'underlying_id', 'order', 'settle_value', 'returns', 'expdate']
                by_product = df2
                continue
            # iterate over rollover dates for this product.
            for date in relevant_dates:
                df = df[df.order > 0]
                order_nums = sorted(df.order.unique())
                breakpoint = max(most_recent) if most_recent else min(
                    df['value_date'])
                # print('breakpoint, date: ', breakpoint, date)
                by_order_num = None
                # iterate over all order_nums for this product. for each cont, grab
                # entries until first breakpoint, and stack wide.
                for ordering in order_nums:
                    # print('breakpoint, end, cont: ', breakpoint, date, cont)
                    df2 = df[df.order == ordering]
                    tdf = df2[(df2['value_date'] < date) & (df2['value_date'] >= breakpoint)][
                        ['pdt', 'value_date', 'underlying_id', 'order', 'settle_value', 'returns', 'expdate']]
                    # print(tdf.empty)
                    tdf.columns = [
                        'pdt', 'value_date', 'underlying_id', 'order', 'settle_value', 'returns', 'expdate']
                    tdf.reset_index(drop=True, inplace=True)
                    by_order_num = tdf if by_order_num is None else pd.concat(
                        [by_order_num, tdf])

                # by_date contains entries from all order_nums until current
                # rollover date. take and stack this long.
                by_date = by_order_num if by_date is None else pd.concat(
                    [by_date, by_order_num])
                most_recent.append(date)
                df.order -= 1

            by_product = by_date if by_product is None else pd.concat(
                [by_product, by_order_num])
        final = by_product

    else:
        final = -1
    elapsed = time.time() - t
    # print('[CI-PRICE] elapsed: ', elapsed)
    # final.to_csv('ci_price_final.csv', index=False)
    return final


def civols(vdf, pdf, rollover='opex'):
    """Constructs the CI vol series.
    Args:
        vdf (TYPE): price data frame of same format as read_data
        rollover (str, optional): the rollover strategy to be used. defaults to opex, i.e. option expiry.

    Returns:
        pandas dataframe : dataframe with the following columns:
        pdt|order|value_date|underlying_id|vol_id|op_id|call_put_id|tau|strike|settle_vol

    """
    t = time.time()
    if rollover == 'opex':
        ro_dates = get_rollover_dates(pdf)
        products = vdf['pdt'].unique()
        # iterate over produts
        by_product = None
        for product in products:
            df = vdf[vdf.pdt == product]
            most_recent = []
            by_date = None
            try:
                relevant_dates = ro_dates[product]
            except KeyError:
                # no rollover dates for this product
                df2 = df[['pdt', 'order', 'value_date', 'underlying_id', 'vol_id',
                          'op_id', 'call_put_id', 'tau', 'strike', 'settle_vol']]
                df2.columns = ['pdt', 'order', 'value_date', 'underlying_id',
                               'vol_id', 'op_id', 'call_put_id', 'tau', 'strike', 'settle_vol']
                by_product = df2
                continue

            # iterate over rollover dates for this product.
            for date in relevant_dates:
                # filter order > 0 to get rid of C_i that have been dealt with.
                df = df[df.order > 0]
                # sort orderings.
                order_nums = sorted(df.order.unique())
                breakpoint = max(most_recent) if most_recent else min(
                    df['value_date'])
                by_order_num = None
                # iterate over all order_nums for this product. for each cont, grab
                # entries until first breakpoint, and stack wide.
                for ordering in order_nums:
                    cols = ['pdt', 'order', 'value_date', 'underlying_id', 'vol_id',
                            'op_id', 'call_put_id', 'tau', 'strike', 'settle_vol']
                    df2 = df[df.order == ordering]
                    tdf = df2[(df2['value_date'] < date) &
                              (df2['value_date'] >= breakpoint)][cols]
                    # renaming columns
                    tdf.columns = ['pdt', 'order', 'value_date', 'underlying_id',
                                   'vol_id', 'op_id', 'call_put_id', 'tau', 'strike', 'settle_vol']
                    # tdf.reset_index(drop=True, inplace=True)
                    by_order_num = tdf if by_order_num is None else pd.concat(
                        [by_order_num, tdf])

                # by_date contains entries from all order_nums until current
                # rollover date. take and stack this long.
                by_date = by_order_num if by_date is None else pd.concat(
                    [by_date, by_order_num])
                most_recent.append(date)
                df.order -= 1

            by_product = by_date if by_product is None else pd.concat(
                [by_product, by_date])

        final = by_product
    else:
        final = -1
    elapsed = time.time() - t
    # print('[CI-VOLS] elapsed: ', elapsed)
    return final


#########################################################################
######################## Old intraday functions #########################
#########################################################################


# def construct_intraday_query_old(pdt, start_date=None, end_date=None, offset=None, contracts=None):
#     """Helper method that generates the SQL query for pulling from the intraday table.

#     Args:
#         pdts (TYPE): Description
#         start_date (None, optional): Description
#         end_date (None, optional): Description
#     """
#     init_query = 'select * from public.table_intra_day_trade where ('

#     # generate product query
#     pdt_str = ''

#     # for pdt in pdts:
#     space = 1 if len(pdt) == 1 else 0
#     pdt_str += ' commodity like '
#     if contracts is not None:
#         for i in contracts:
#             pdt_str += "'" + pdt + ' '*space + i + '%%' + "'"
#     else:
#         pdt_str += "'" + pdt + ' '*space + '%%' + "'"

#     pdt_str += ' ) '

#     init_query += pdt_str

#     date_str = ''

#     # add in date conditions
#     if start_date is not None or end_date is not None:
#         if offset is not None:
#             start_date = (pd.to_datetime(start_date) -
#                           BDay(offset)).strftime('%Y-%m-%d')

#         date_str += ' and ('
#         if start_date is not None:
#             date_str += ' date(date_time) >= ' + "'" + start_date + "'"
#             if end_date is None:
#                 date_str += ' )'
#             else:
#                 date_str += ' and '

#         if end_date is not None:
#             date_str += ' date(date_time) <= ' + "'" + end_date + "'" + ')'

#     init_query += ' ' + date_str

#     # print('init_query: ', init_query)
#     return init_query


# def _pull_intraday_data_old(pdt, start_date=None, end_date=None, filepath='', contracts=None, overnight_pdts=None):
#     """Helper method that is called in pull_intraday_data in parallel if necessary.

#     Args:
#         pdt (str): product.
#         start_date (str, optional): start date
#         end_date (str, optional): end date
#         filepath (str, optional): path to write the data to.
#         contracts (list, optional): contracts to be pulled in particular
#         overnight_pdts (set, optional): set of overnight products.

#     Returns:
#         dataframe: dataframe of cleaned intraday data.
#     """
#     vid_str = '_'.join([x for x in contracts]
#                        ) if contracts is not None else ''
#     filename = pdt + '_' + start_date + '_' + end_date + '_ ' + vid_str + \
#         '_raw_intraday_data.csv'
#     fullpath = filepath + filename

#     print('fullpath: ', fullpath)
#     if os.path.exists(fullpath):
#         print('raw file for ' + pdt + ' exists, reading in.')
#         df = pd.read_csv(fullpath)
#         if contracts is not None:
#             df = df[df.commodity.str.contains(
#                 '|'.join([x for x in contracts]))]

#         df.date_time = pd.to_datetime(df.date_time)

#     else:
#         print('raw file for ' + pdt + ' does not exist, pulling.')
#         user = 'sumit'
#         password = 'Olam1234'
#         engine = create_engine('postgresql://' + user + ':' + password +
#                                '@gmoscluster.cpmqxvu2gckx.us-west-2.redshift.amazonaws.com:5439/analyticsdb')
#         connection = engine.connect()
#         print('constructing query...')
#         offset = 1 if pdt in overnight_pdts else 0
#         query = construct_intraday_query_old(
#             pdt, start_date=start_date, end_date=end_date, offset=offset, contracts=contracts)
#         print('query: ', query)

#         # fetch the dataframe from the db.

#         print('fetching intraday data...')
#         df = pd.read_sql_query(query, connection)
#         df.to_csv(fullpath, index=False)
#         connection.close()

#     df = clean_intraday_data(df, pd.to_datetime(start_date),
#                              pd.to_datetime(end_date), filepath=filepath)

#     df = handle_intraday_conventions(df)

#     df.value_date = pd.to_datetime(df.value_date)
#     df.sort_values(by=['value_date', 'time'], inplace=True)
#     df.reset_index(drop=True, inplace=True)

#     return df


# def pull_intraday_data_old(pdts, start_date=None, end_date=None, filepath='', contracts=None):
#     """Helper method that pulls intraday data from the DB.

#     Args:
#         pdts (TYPE): Products for which intraday data is required
#         start_date (None, optional): start date
#         end_date (None, optional): end date
#         filepath (str, optional): Description
#         contracts (None, optional): Description

#     Returns:
#         TYPE: Dataframe
#     """
#     overnight_pdts = {'BO', 'C', 'KW', 'S', 'SM', 'W', 'CT', 'MW'}

#     t = time.clock()

#     par = True if len(pdts) > 1 else False

#     if not par:
#         df = _pull_intraday_data_old(pdts[0], start_date=start_date, end_date=end_date,
#                                      filepath=filepath, contracts=contracts,
#                                      overnight_pdts=overnight_pdts)
#     else:
#         res = Parallel(n_jobs=len(pdts))(delayed(_pull_intraday_data_old)(pdt, start_date=start_date, end_date=end_date,
#                                                                           filepath=filepath, contracts=contracts,
#                                                                           overnight_pdts=overnight_pdts) for pdt in pdts)
#         df = pd.concat(res)

#     print('elapsed: ', time.clock() - t)

#     return df
